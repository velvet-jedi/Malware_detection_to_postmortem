from http.server import BaseHTTPRequestHandler, HTTPServer
#BaseHTTPRequestHandler = class provided by the http.server to handle HTTP requests
# HTTPServer = a class provided by the http.server module that creates an HTTP server

import re

host = "localhost"
port = 8000


#########
# Handle the response here 
#########

# ServerHandler is a custom class inheriting from BaseHTTPRequestHandler
class ServerHandler(BaseHTTPRequestHandler):

    def block_request(self):
        self.send_response(403) # Forbidden
        self.send_header("content-type", "text/plain")
        self.end_headers()
        print("Blocking request")
    
    def handle_request(self):
        self.send_response(200)
        self.send_header("content-type", "application/json")
        self.end_headers()     # for ending the headers section of an HTTP response.



    def should_block_request(self):
        # Check if the request path matches the blocked path
        blocked_path = "/tomcatwar.jsp"
        if self.path == blocked_path: # path portion of the URL in an incoming HTTP request ("http://localhost:8000/some_path", self.path will contain the string "/some_path").
                        # what is being requested to be accessed
            return True

        # define the blocked headers as a dictionary (collection of key-value pairs) 
        blocked_headers = {
            "suffix": r"%>//",
            "c1": r"Runtime",
            "c2": r"<%",
            "DNT": r"1",
            "Content-Type": r"application/x-www-form-urlencoded"
        }                   

        
        for header, pattern in blocked_headers.items(): # blocked_headers.items() is a method that returns a sequence of tuples For example, it might return ("suffix", r"%">//"), then ("c1", r"Runtime")
# iterate through these key-value pairs, assigning the key (header name) to the variable header and the value (regular expression pattern) to the variable pattern in each iteration.              
            # In the first iteration, header is "suffix" and pattern is r"%>//".
            # self object is an instance of the ServerHandler 
            # self.headers refers to the headers of an incoming HTTP request
# When an HTTP request is received by the server,
# an instance of ServerHandler is created to handle that specific request. 
# This instance has access to the request headers through the self.headers
            if header in self.headers and re.search(pattern, self.headers[header]):
                return True

        return False    # requests should not be blocked by default.
    
    # Define how to handle GET requests.
    def do_GET(self):
        if self.should_block_request(): # If the request should be blocked, call the block_request method.
            self.block_request()
        else:
            self.handle_request()


    # Define how to handle POST requests.
    def do_POST(self):
        if self.should_block_request(): # If the request should be blocked, call the block_request method.
            self.block_request()
        else:
            self.handle_request()


if __name__ == "__main__":        
    server = HTTPServer((host, port), ServerHandler)
    # (host, port) is a tuple
    print("[+] Firewall Server")
    print("[+] HTTP Web Server running on: %s:%s" % (host, port))


    # for handling keyboard interrupt
    try:
        server.serve_forever()  # Start serving requests indefinitely
    except KeyboardInterrupt:
        pass   # when a keyboard interrupt occurs, the program should simply do nothing and continue to the next line of code, 
               # allowing for a graceful termination of the server when done

    print("[+] Server terminated. Exiting...")  
    exit(0)